### Optional Pattern

In Java, Optional doesn't solve the NPE problem. It just wraps it and "protects" our return values.

```java
Optional<String> getCity(String user) {
  var city = getOptionalCity(user);
  if (city != null) 
    return Optional.of(city);
  else
    return Optional.empty();
}
```

It should not be used on parameters or properties.

```java
getPermissions(user, null);
getPermissions(user, Optional.empty());  // Not recommended
```

Solution: Nullability is built into the type system.
String != String

```kotlin
val myString: String = "hello"
val nullableString: String? = null   // correct!!
```

```kotlin
myString = null         // Compiler error
nullableString.length   // Compiler error, since the checking has not been done
```

This works for parameters, return types, properties and generics.

```kotlin
val list: List<String>
list.add(null)   // Compiler error
```

### Overloading Methods

```java
void log(String msg) { ......... }
void log(String msg, String level) { ......... }
void log(String msg, String level, String ctx) { ......... }
```

In kotlin we declare only one function, because we have default arguments and named arguments.

```kotlin
fun log(
    msg: String, 
    level: String = "INFO", 
    ctx: String = "main"
) { 
......... 
}

```kotlin
log(level="DEBUG", msg="trace B")
```

### Utility class with static methods

```java
final class NumberUtils {
  public static boolean isEven(final int i) {
    return i % 2 == 0;
  }
}
```

In some projects we may end up declaring the same utility function more than once.

```kotlin
fun Int.isEven() = this % 2 == 0  // Extension function

2.isEven()
```

```kotlin
val Int.isEven: Boolean          // Extension property
  get() = this % 2 == 0

2.isEven()
```

### Factory

```java
public class NotificationFactory {

  public static Notification createNotification(
        final NotificationType type
  ) {
      return switch(type) {
        case Email -> new EmailNotification();
        case SMS -> new SmsNotification();
      };
  }
}
```

In Kotlin a function is used instead of an interface

```kotlin
//  This would be a code smell in Java
fun Notification(type: NotificationType) = when(type) {
    NotificationType.Email -> EmailNotification()
    NotificationType.SMS -> SmsNotification()
  }
}

val notification = Notification(NotificationType.Email)
```

### Singleton

```java
// Much code, it's not even thread-safe
public final class MySingleton {
    private static final MySingleton INSTANCE;

    private MySingleton() {}

    public static MySingleton getInstance() {
        if (INSTANCE == null) {
            INSTANCE = new MySingleton();
        }
        return INSTANCE;
    }
}
```

This pattern is built into the Kotlin language. It's lazy and thread-safe.

```kotlin
object Singleton {
  val myProperty......
  fun myInstanceMethod() {
    ...............
  }
}
```
























