### Optional Pattern

In Java, Optional doesn't solve the NPE problem. It just wraps it and "protects" our return values.

```java
Optional<String> getCity(String user) {
  var city = getOptionalCity(user);
  if (city != null) 
    return Optional.of(city);
  else
    return Optional.empty();
}
```

It should not be used on parameters or properties.

```java
getPermissions(user, null);
getPermissions(user, Optional.empty());  // Not recommended
```

Solution: Nullability is built into the type system.
String != String

```kotlin
val myString: String = "hello"
val nullableString: String? = null   // correct!!
```

```kotlin
myString = null         // Compiler error
nullableString.length   // Compiler error, since the checking has not been done
```

This works for parameters, return types, properties and generics.

```kotlin
val list: List<String>
list.add(null)   // Compiler error
```

### Overloading Methods

```java
void log(String msg) { ......... }
void log(String msg, String level) { ......... }
void log(String msg, String level, String ctx) { ......... }
```

In kotlin we declare only one function, because we have default arguments and named arguments.

```kotlin
fun log(
    msg: String, 
    level: String = "INFO", 
    ctx: String = "main"
) { 
......... 
}

```kotlin
log(level="DEBUG", msg="trace B")
```

### Utility class with static methods

```java
final class NumberUtils {
  public static boolean isEven(final int i) {
    return i % 2 == 0;
  }
}
```

In some projects we may end up declaring the same utility function more than once.

```kotlin
fun Int.isEven() = this % 2 == 0  // Extension function

2.isEven()
```

```kotlin
val Int.isEven: Boolean          // Extension property
  get() = this % 2 == 0

2.isEven()
```
























